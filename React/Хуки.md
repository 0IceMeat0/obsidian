useState -
Исп. для добавления состояния в функциональных компонентах.
useState() - возвращает массив, в котором первый элемент - текущие значение состояния, а второй элемент - функция для обновления состояния. useState() - всегда обновляет объект полностью, а не как setState, который только отдельные поля.

useEffect -
Исп. для добавления эффектов в функциональном компоненте.
В useEffect используется массив зависимостей - (это список переменных состояние или функций, от которых зависит хук, при изменение которых срабатывает функции обратного вызова useEffect), который может предотвратить чрезмерное повторение. Если скобки остались пустые, то это равносильно одному разу.
Внутри useEffect можно сделать очистку, которая используется для удаление нежелательного поведения. Функция очистки вызывается перед размонтированием следующего эффекта.

useCallback - делает тоже самое, только с функциями, делает им запись и при пере-рендеринг функция не перезаписывается, нужно понимать это нужно чтобы лишний раз не делать лишнее обновление 
пример:

у нас есть тег Car и чтобы не переделывать весь массив cars, мы используем хук useCallBack

```
const onCarClick = useCallback((car) => {
console.log(car.module)
}, []);

return cars.map((car) => {
return (
<Car key={car.id} car={car} onClick={onCarClick(car)} />
)
});

```

А вот внутри Car, нет смысла использовать callback, так как он затратный и нет смысла в нем.
```
const onClickButton = () => onCarClick(car);

return (
<button onClick={onClickButton}>
{car.model}
</button>
);
```

useMemo - помогает нам кешировать данные и при пере-рендеринге, если объект не изменяется. На самом деле, если твое решение имеет много зависимостей или часто меняется, не всегда вариант с мемо может тебе подходить, так как он дорогостоящий.

useRef - позволяет создавать и управлять ссылками. Аналогично работы ref в классовых компонентах.

useContext - используется для получения значений контекста в функциональном компоненте 

useReducer - нужен, когда у вас сложная логика, которая включает в себя несколько значений или когда обновляемое состояние зависит от предыдущего. Также позволяет оптимизировать компонент, так как вы можете передать dispatch из вне вместо коллбэка.

useLayoutEffect - если нам нужно выполнить какой-то код, до отрисовки в браузере, нам предоставили хук `useLayoutEffect`, интерфейс которого полностью совпадает с `useEffect`, но по очередности выполнения полностью совпадает с `componentDidMount`.
https://habr.com/ru/articles/532224/ - useLayoutEffect(тут показываю, почему useEffect отличается от componentDidMount)

