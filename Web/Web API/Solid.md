## S
single responsibility principle
принцип единственной ответственности

1 сущность = 1 задача
Избавляемся от паттерна objgod(когда объект может делать все задачи сразу)
И тем самым появляется модульность в коде


## O
open-closed principle
принцип открытости/закрытости 
открыты для расширения и закрыты для изменения
То есть нужно уменьшить изменение старого кода и добавление новых метод (Путем расширения). А если происходит 


## l
liskov substitution principle
принцип постановки Барбары Лисков
Наследуемый класс должен дополнять, а не замещать поведение базового класса 

## i
interface segregation principle
принцип разделение интерфейса
При проектирование интерфейсов нужно продумывать их так, что они подходили для конкретного клиента. А не делать супер общие решение.
Код становится менее связанным. 
Избавляем программные сущности от методов, которые они не используют.
## D
Dependency inversion principle
Принцип инверсии зависимости
Модули высокого уровня не должны зависеть от модулей низкого уровня, все должны зависеть от абстракций, а абстракции не должны зависеть от деталей 